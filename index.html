<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pixel Tower Defense</title>
    <style>
        /* Your existing CSS styles */
        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: 'Courier New', Courier, monospace;
            touch-action: none; /* Disable touch gestures like pinch-to-zoom */
        }
        canvas { 
            display: block; 
        }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            user-select: none;
            display: none; /* Initially hidden */
            font-size: 20px; /* Larger font for mobile */
        }
        #tower-selection {
            position: absolute;
            bottom: 10px;
            left: 10px;
            display: flex;
            gap: 10px;
            display: none; /* Initially hidden */
        }
        .tower-button {
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px; /* Larger padding for mobile */
            border: 2px solid white;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px; /* Larger font for mobile */
        }
        .tower-button:hover {
            background-color: rgba(50, 50, 50, 0.7);
        }
        .tower-button.selected {
            border-color: yellow;
            background-color: rgba(100, 100, 50, 0.7);
        }
        #start-wave {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background-color: rgba(0, 100, 0, 0.7);
            color: white;
            padding: 15px 30px; /* Larger padding for mobile */
            border: 2px solid white;
            border-radius: 5px;
            cursor: pointer;
            display: none; /* Initially hidden */
            font-size: 16px; /* Larger font for mobile */
        }
        #start-wave:hover {
            background-color: rgba(0, 150, 0, 0.7);
        }
        #main-menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: white;
            background-color: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            user-select: none;
        }
        #main-menu button {
            background-color: rgba(0, 100, 0, 0.7);
            color: white;
            padding: 15px 30px; /* Larger padding for mobile */
            border: 2px solid white;
            border-radius: 5px;
            cursor: pointer;
            margin: 10px;
            font-size: 16px; /* Larger font for mobile */
        }
        #main-menu button:hover {
            background-color: rgba(0, 150, 0, 0.7);
        }
        #instructions {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            background-color: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            user-select: none;
            text-align: left;
        }
        #instructions button {
            background-color: rgba(0, 100, 0, 0.7);
            color: white;
            padding: 15px 30px; /* Larger padding for mobile */
            border: 2px solid white;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 10px;
            font-size: 16px; /* Larger font for mobile */
        }
        #instructions button:hover {
            background-color: rgba(0, 150, 0, 0.7);
        }
        #click-prompt {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            user-select: none;
        }
        #leaderboard {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            background-color: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            display: none;
            text-align: center;
        }
        #player-name-input {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            background-color: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            display: none;
            text-align: center;
        }
    </style>
</head>
<body>
    <!-- Main Menu -->
    <div id="main-menu">
        <h1>Pixel Tower Defense</h1>
        <button id="start-game">Start Game</button>
        <button id="show-instructions">Instructions</button>
        <button id="view-leaderboard">View Leaderboard</button>
        <button id="exit-game">Exit</button>
    </div>

    <!-- Instructions -->
    <div id="instructions">
        <h2>Instructions</h2>
        <p>Welcome to Pixel Tower Defense!</p>
        <p>1. Place towers on the grid to defend against incoming enemies.</p>
        <p>2. Towers have different abilities and costs.</p>
        <p>3. Enemies will follow a path, and if they reach the end, you lose lives.</p>
        <p>4. Survive all waves to win the game!</p>
        <button id="back-to-menu">Back to Menu</button>
    </div>

    <!-- Game UI -->
    <div id="ui">
        <div>Gold: <span id="gold">100</span></div>
        <div>Lives: <span id="lives">20</span></div>
        <div>Wave: <span id="wave">0</span>/25</div>
    </div>
    <div id="tower-selection">
        <div class="tower-button" data-type="laser" data-cost="50">Laser Tower<br>$50</div>
        <div class="tower-button" data-type="cannon" data-cost="75">Cannon Tower<br>$75</div>
        <div class="tower-button" data-type="sniper" data-cost="100">Sniper Tower<br>$100</div>
    </div>
    <button id="start-wave">Start Wave</button>

    <!-- Leaderboard -->
    <div id="leaderboard"></div>

    <!-- Player Name Input -->
    <div id="player-name-input">
        <input type="text" id="player-name" placeholder="Enter your name">
        <button id="submit-score">Submit Score</button>
    </div>

    <!-- Click Prompt -->
    <div id="click-prompt">Click anywhere to start</div>

    <!-- Audio Elements -->
    <audio id="canon-sound" src="assets/canon sound.wav" preload="auto"></audio>
    <audio id="click-sound" src="assets/click sound.wav" preload="auto"></audio>
    <audio id="enemy-death-sound" src="assets/enemies death sound.wav" preload="auto"></audio>
    <audio id="game-music" src="assets/Game Music.mp3" preload="auto"></audio>
    <audio id="game-over-sound" src="assets/game over sound.wav" preload="auto"></audio>
    <audio id="laser-sound" src="assets/laser sound.wav" preload="auto"></audio>
    <audio id="sniper-sound" src="assets/sniper sound.wav" preload="auto"></audio>
    <audio id="title-music" src="assets/Title Screen Music.mp3" preload="auto"></audio>
    <audio id="upgrade-sound" src="assets/upgrade sound.wav" preload="auto"></audio>

    <!-- Three.js and Game Script -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script>
        // Initialize Supabase
        const supabaseUrl = 'https://ivwubazshhwdwbcovuuk.supabase.co';
        const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Iml2d3ViYXpzaGh3ZHdiY292dXVrIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDE0MDE2NTksImV4cCI6MjA1Njk3NzY1OX0.lxZJhKqhoMxR68utgVdiY8UDi3W1RKhvzFEMEOvb8ws';
        const supabase = supabase.createClient(supabaseUrl, supabaseKey);

        console.log("Supabase initialized:", supabase);

        // Test Supabase connection
        async function testSupabase() {
            const { data, error } = await supabase
                .from("scores")
                .select("*")
                .limit(1);

            if (error) {
                console.error("Supabase connection error:", error);
            } else {
                console.log("Supabase connection successful:", data);
            }
        }

        testSupabase();

// Game state
const gameState = {
    gold: 100,
    lives: 20,
    currentWave: 0,
    waveInProgress: false,
    selectedTower: null,
    towers: [],
    enemies: [],
    projectiles: []
};

// Save score to Supabase
async function saveScore(playerName, score) {
    const { data, error } = await supabaseClient
        .from("scores")
        .insert([{ name: playerName, score: score }]);
    if (error) {
        console.error("Error saving score:", error);
    } else {
        console.log("Score saved successfully:", data);
    }
}

// Retrieve leaderboard from Supabase
async function getLeaderboard() {
    const { data, error } = await supabaseClient
        .from("scores")
        .select("*")
        .order("score", { ascending: false })
        .limit(10);
    if (error) {
        console.error("Error fetching leaderboard:", error);
        return [];
    }
    return data;
}

// Display leaderboard
async function displayLeaderboard() {
    const leaderboard = await getLeaderboard();
    const leaderboardElement = document.getElementById("leaderboard");
    leaderboardElement.innerHTML = "<h2>Leaderboard</h2>";
    leaderboard.forEach((entry, index) => {
        const entryElement = document.createElement("div");
        entryElement.textContent = `${index + 1}. ${entry.name}: ${entry.score}`;
        leaderboardElement.appendChild(entryElement);
    });
    leaderboardElement.style.display = "block";
}

// Show player name input when the game ends
function gameOver() {
    alert(`Game Over! You survived ${gameState.currentWave} waves.`);
    document.getElementById("player-name-input").style.display = "block";
}

// Submit score when the player enters their name
document.getElementById("submit-score").addEventListener("click", async () => {
    const playerName = document.getElementById("player-name").value;
    if (playerName) {
        await saveScore(playerName, gameState.currentWave);
        document.getElementById("player-name-input").style.display = "none";
    }
});

// View leaderboard
document.getElementById("view-leaderboard").addEventListener("click", () => {
    displayLeaderboard();
});

        
// Add this line
const mouse = new THREE.Vector2();

// Variable for fast forward mode
let fastMode = false;
        
        // Check if the device is a touch device
        function isTouchDevice() {
            return 'ontouchstart' in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;
        }

        // Play title music on first user interaction (click anywhere on the page)
        function playTitleMusic() {
            const titleMusic = document.getElementById('title-music');
            titleMusic.play();
            titleMusic.loop = true; // Ensure the music loops

            // Hide the click prompt
            document.getElementById('click-prompt').style.display = 'none';

            // Remove the event listener after the first interaction
            document.removeEventListener('click', playTitleMusic);
            document.removeEventListener('touchstart', playTitleMusic); // For mobile devices
        }

        // Add event listeners for both click and touchstart (for mobile devices)
        document.addEventListener('click', playTitleMusic);
        document.addEventListener('touchstart', playTitleMusic);

        // Tower types
        const towerTypes = {
            laser: {
                cost: 50,
                damage: 2,
                range: 5,
                fireRate: 0.5, // seconds between shots
                color: 0xff0000,
                upgradeLevel: 0,
                upgrades: [
                    { cost: 75, damage: 3, range: 5, fireRate: 0.5 },
                    { cost: 125, damage: 3, range: 5, fireRate: 0.3 },
                    { cost: 200, damage: 4, range: 6, fireRate: 0.3 }
                ]
            },
            cannon: {
                cost: 75,
                damage: 6,
                range: 4,
                fireRate: 1.2,
                splashRadius: 5,
                color: 0x0000ff,
                upgradeLevel: 0,
                upgrades: [
                    { cost: 100, damage: 7, range: 4, fireRate: 1.2, splashRadius: 2.5 },
                    { cost: 150, damage: 8, range: 4, fireRate: 1.2, splashRadius: 2.5 },
                    { cost: 250, damage: 10, range: 5, fireRate: 1.0, splashRadius: 3.5 }
                ]
            },
            sniper: {
                cost: 100,
                damage:10,
                range: 10,
                fireRate: 2.0,
                color: 0x00ff00,
                upgradeLevel: 0,
                upgrades: [
                    { cost: 125, damage: 12, range: 12, fireRate: 2.0 },
                    { cost: 175, damage: 12, range: 15, fireRate: 1.8 },
                    { cost: 300, damage: 15, range: 18, fireRate: 1.8 }
                ]
            }
        };


        // Enemy types
        const enemyTypes = {
            square: {
                health: 10,
                speed: 2,
                reward: 10,
                damage: 1, // lives lost when reaching exit
                color: 0xff0000,
                size: 0.7
            },
            circle: {
                health: 5,
                speed: 3.5,
                reward: 5,
                damage: 1,
                color: 0x00ffff,
                size: 0.5
            },
            triangle: {
                health: 20,
                speed: 1.5,
                reward: 20,
                damage: 2,
                color: 0xffff00,
                size: 0.8
            },
            pentagon: {
                health: 50,
                speed: 1,
                reward: 50,
                damage: 5,
                color: 0xff00ff,
                size: 1
            }
        };

        // Wave definitions
        const waves = generateWaves();

        // Setup scene
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB); // Sky blue background
        
        // Setup camera
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 15, 15);
        
        // Setup renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);
        
        // Add orbit controls
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.screenSpacePanning = false;
        controls.minDistance = 5;
        controls.maxDistance = 30;
        controls.maxPolarAngle = Math.PI / 2;
        
        // Create lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 20, 10);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        scene.add(directionalLight);
        
        // Setup game grid
        const gridSize = 20;
        const cellSize = 1;
        const grid = [];
        
        // Create grid of terrain
        const terrainGeometry = new THREE.BoxGeometry(cellSize, 0.2, cellSize);
        const terrainMaterials = {
            grass: new THREE.MeshLambertMaterial({ color: 0x7CFC00 }),
            water: new THREE.MeshLambertMaterial({ color: 0x4169E1 }),
            rock: new THREE.MeshLambertMaterial({ color: 0x808080 }),
            path: new THREE.MeshLambertMaterial({ color: 0xD2B48C })
        };
        
        // Create the path for enemies to follow
        const path = createPath();
        const pathPoints = path.getPoints(100);
        
        for (let x = 0; x < gridSize; x++) {
            grid[x] = [];
            for (let z = 0; z < gridSize; z++) {
                const worldX = (x - gridSize / 2) * cellSize;
                const worldZ = (z - gridSize / 2) * cellSize;
                
                // Check if this cell is part of the path
                const isPath = isPointNearPath(worldX, worldZ, pathPoints, cellSize * 0.75);
                
                // Determine terrain type
                let terrainType;
                if (isPath) {
                    terrainType = 'path';
                } else {
                    // Random terrain for non-path cells
                    const terrainRandom = Math.random();
                    if (terrainRandom < 0.1) {
                        terrainType = 'water';
                    } else if (terrainRandom < 0.2) {
                        terrainType = 'rock';
                    } else {
                        terrainType = 'grass';
                    }
                }
                
                const terrain = new THREE.Mesh(terrainGeometry, terrainMaterials[terrainType]);
                terrain.position.set(worldX, 0, worldZ);
                terrain.receiveShadow = true;
                scene.add(terrain);
                
                grid[x][z] = {
                    type: terrainType,
                    mesh: terrain,
                    tower: null,
                    worldX,
                    worldZ
                };
            }
        }
        
        // Create a visual representation of the path
        visualizePath(path);
        
        // Raycaster for touch interaction
        const raycaster = new THREE.Raycaster();
        const touch = new THREE.Vector2();

// Event listeners based on device type
if (isTouchDevice()) {
    window.addEventListener('touchstart', onTouchStart, { passive: false });
    window.addEventListener('touchmove', onTouchMove, { passive: false });
    window.addEventListener('touchend', onTouchEnd);
} else {
    window.addEventListener('mousemove', onMouseMove);
    window.addEventListener('click', onMouseClick);
}
        
        // Event listeners for touch devices
        window.addEventListener('resize', onWindowResize);
        window.addEventListener('touchstart', onTouchStart);
        window.addEventListener('touchmove', onTouchMove);
        window.addEventListener('touchend', onTouchEnd);
        
        document.querySelectorAll('.tower-button').forEach(button => {
            button.addEventListener('click', selectTower);
        });
        
        document.getElementById('start-wave').addEventListener('click', startWave);
        
        // Main Menu Event Listeners
        document.getElementById('start-game').addEventListener(isTouchDevice() ? 'touchstart' : 'click', startGame);
        document.getElementById('show-instructions').addEventListener(isTouchDevice() ? 'touchstart' : 'click', showInstructions);
        document.getElementById('exit-game').addEventListener(isTouchDevice() ? 'touchstart' : 'click', exitGame);
        document.getElementById('back-to-menu').addEventListener(isTouchDevice() ? 'touchstart' : 'click', backToMenu);

        // Tower Selection Buttons
        document.querySelectorAll('.tower-button').forEach(button => {
            button.addEventListener(isTouchDevice() ? 'touchstart' : 'click', selectTower);
        });

        // Start Wave Button
        document.getElementById('start-wave').addEventListener(isTouchDevice() ? 'touchstart' : 'click', startWave);

        // Animation loop
        let lastTime = 0;
        function animate(time) {
            requestAnimationFrame(animate);
            
            const deltaTime = (time - lastTime) / 1000; // Convert to seconds
            lastTime = time;
            
            updateGame(deltaTime);
            controls.update();
            renderer.render(scene, camera);
        }
        
        // Start the animation loop
        animate(0);
        
        // Handle window resize
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Handle mouse movement for grid highlighting
function onMouseMove(event) {
    event.preventDefault();
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
    
    highlightGrid();
}

// Handle mouse click for tower placement
function onMouseClick(event) {
    event.preventDefault();
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
    
    if (!gameState.selectedTower) return;
    
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObjects(scene.children);
    
    if (intersects.length > 0) {
        // Find the first intersection that is a grid cell (terrain)
        for (const intersect of intersects) {
            const object = intersect.object;
            
            // Skip towers and their children when finding placement cells
            let isTower = false;
            for (const tower of gameState.towers) {
                if (object === tower.mesh || tower.mesh.children.includes(object)) {
                    isTower = true;
                    break;
                }
            }
            
            if (!isTower) {
                const cell = getCellFromPosition(object.position.x, object.position.z);
                
                if (cell && canPlaceTower(cell)) {
                    placeTower(cell, gameState.selectedTower);
                    break;
                }
            }
        }
    }
}

// Add mouse event listeners for desktop
if (!isTouchDevice()) {
    window.addEventListener('mousemove', onMouseMove);
    window.addEventListener('click', onMouseClick);
}
        
        // Handle touch movement for grid highlighting
        function onTouchMove(event) {
            event.preventDefault();
            const touchEvent = event.touches[0];
            touch.x = (touchEvent.clientX / window.innerWidth) * 2 - 1;
            touch.y = -(touchEvent.clientY / window.innerHeight) * 2 + 1;
            
            highlightGrid();
        }
        
        // Handle touch start for tower placement
        function onTouchStart(event) {
            event.preventDefault();
            const touchEvent = event.touches[0];
            touch.x = (touchEvent.clientX / window.innerWidth) * 2 - 1;
            touch.y = -(touchEvent.clientY / window.innerHeight) * 2 + 1;
            
            if (!gameState.selectedTower) return;
            
            raycaster.setFromCamera(touch, camera);
            const intersects = raycaster.intersectObjects(scene.children);
            
            if (intersects.length > 0) {
                // Find the first intersection that is a grid cell (terrain)
                for (const intersect of intersects) {
                    const object = intersect.object;
                    
                    // Skip towers and their children when finding placement cells
                    let isTower = false;
                    for (const tower of gameState.towers) {
                        if (object === tower.mesh || tower.mesh.children.includes(object)) {
                            isTower = true;
                            break;
                        }
                    }
                    
                    if (!isTower) {
                        const cell = getCellFromPosition(object.position.x, object.position.z);
                        
                        if (cell && canPlaceTower(cell)) {
                            placeTower(cell, gameState.selectedTower);
                            break;
                        }
                    }
                }
            }
        }
        
        // Handle touch end
        function onTouchEnd(event) {
            event.preventDefault();
        }
        
        // Handle tower selection
        function selectTower(event) {
            const towerType = event.currentTarget.dataset.type;
            const towerCost = parseInt(event.currentTarget.dataset.cost);
            
            // Deselect all buttons
            document.querySelectorAll('.tower-button').forEach(button => {
    button.addEventListener(isTouchDevice() ? 'touchstart' : 'click', selectTower);
});
            
            if (gameState.selectedTower === towerType) {
                // Deselect if clicking the same tower
                gameState.selectedTower = null;
            } else {
                // Select the new tower
                gameState.selectedTower = towerType;
                event.currentTarget.classList.add('selected');
            }
        }
        
        // Start a new wave
        function startWave() {
            if (gameState.waveInProgress || gameState.currentWave >= waves.length) return;
            
            gameState.currentWave++;
            document.getElementById('wave').textContent = gameState.currentWave;
            gameState.waveInProgress = true;
            
            const wave = waves[gameState.currentWave - 1];
            let enemyIndex = 0;
            
            // Spawn enemies at intervals
            const spawnInterval = setInterval(() => {
                if (enemyIndex >= wave.length) {
                    clearInterval(spawnInterval);
                    return;
                }
                
                spawnEnemy(wave[enemyIndex]);
                enemyIndex++;
                
                if (enemyIndex >= wave.length) {
                    clearInterval(spawnInterval);
                }
            }, 1000); // Spawn an enemy every second
        }
        
        // Update game state
        function updateGame(deltaTime) {
            updateTowers(deltaTime);
            updateEnemies(deltaTime);
            updateProjectiles(deltaTime);
            checkWaveComplete();
        }
        
        // Update towers (fire at enemies)
        function updateTowers(deltaTime) {
            for (const tower of gameState.towers) {
                tower.cooldown -= deltaTime;
                
                if (tower.cooldown <= 0) {
                    const target = findTarget(tower);
                    
                    if (target) {
                        fireTower(tower, target);
                        tower.cooldown = tower.fireRate;
                    }
                }
            }
        }
        
        // Update enemies (move along path)
        function updateEnemies(deltaTime) {
            for (let i = gameState.enemies.length - 1; i >= 0; i--) {
                const enemy = gameState.enemies[i];
                
                // Move enemy along path
                enemy.pathPosition += enemy.speed * deltaTime / 20; // Adjust for path length
                
                if (enemy.pathPosition >= 1) {
                    // Enemy reached the end
                    takeDamage(enemy.damage);
                    removeEnemy(i);
                    continue;
                }
                
                // Update position
                const position = path.getPointAt(enemy.pathPosition);
                enemy.mesh.position.set(position.x, enemy.height, position.y);
                
                // Rotate enemy to face direction of movement
                if (enemy.pathPosition < 0.99) {
                    const ahead = path.getPointAt(Math.min(1, enemy.pathPosition + 0.01));
                    const direction = new THREE.Vector2().subVectors(ahead, position).normalize();
                    const angle = Math.atan2(direction.y, direction.x);
                    enemy.mesh.rotation.y = -angle + Math.PI / 2;
                }
                
                // Update health bar position
                updateHealthBar(enemy);
            }
        }
        
        // Update projectiles
        function updateProjectiles(deltaTime) {
            for (let i = gameState.projectiles.length - 1; i >= 0; i--) {
                const projectile = gameState.projectiles[i];
                
                if (projectile.type === 'laser') {
                    // Laser is instant hit, so we remove it quickly
                    projectile.lifetime -= deltaTime;
                    
                    if (projectile.lifetime <= 0) {
                        scene.remove(projectile.mesh);
                        gameState.projectiles.splice(i, 1);
                    }
                } else {
                    // Move other projectiles
                    const direction = projectile.direction.clone().normalize();
                    projectile.mesh.position.add(direction.multiplyScalar(projectile.speed * deltaTime));
                    
                    // Check if projectile hit target or went too far
                    if (projectile.target.mesh.parent === null) {
                        // Target is already destroyed
                        scene.remove(projectile.mesh);
                        gameState.projectiles.splice(i, 1);
                    } else {
                        const distance = projectile.mesh.position.distanceTo(projectile.target.mesh.position);
                        
                        if (distance < 0.5) {
                            // Hit the target
                            if (projectile.type === 'cannon') {
                                // Splash damage
                                dealSplashDamage(projectile.target.mesh.position, projectile.splashRadius, projectile.damage);
                            } else {
                                // Direct damage
                                damageEnemy(projectile.target, projectile.damage);
                            }
                            
                            scene.remove(projectile.mesh);
                            gameState.projectiles.splice(i, 1);
                        } else if (distance > 30) {
                            // Projectile went too far
                            scene.remove(projectile.mesh);
                            gameState.projectiles.splice(i, 1);
                        }
                    }
                }
            }
        }
        
        // Check if the current wave is complete
        function checkWaveComplete() {
            if (gameState.waveInProgress && gameState.enemies.length === 0) {
                gameState.waveInProgress = false;
                
                // Check if game is complete
                if (gameState.currentWave >= waves.length) {
                    alert('Congratulations! You completed all waves!');
                }
            }
        }
        
        function highlightGrid() {
    // Use appropriate pointer data based on device type
    const pointer = isTouchDevice() ? touch : mouse;
    raycaster.setFromCamera(pointer, camera);
    
    const intersects = raycaster.intersectObjects(scene.children);
    
    // Reset all cell highlighting
    for (let x = 0; x < gridSize; x++) {
        for (let z = 0; z < gridSize; z++) {
            const cell = grid[x][z];
            if (cell.type !== 'path') {
                cell.mesh.material.emissive.setHex(0x000000); // Reset highlight
            }
        }
    }
    
    if (intersects.length > 0) {
        // Find the first intersection that is a grid cell (terrain)
        for (const intersect of intersects) {
            const object = intersect.object;
            
            // Skip towers and their children when finding placement cells
            let isTower = false;
            for (const tower of gameState.towers) {
                if (object === tower.mesh || tower.mesh.children.includes(object)) {
                    isTower = true;
                    break;
                }
            }
            
            if (!isTower) {
                const cell = getCellFromPosition(object.position.x, object.position.z);
                
                if (cell) {
                    if (gameState.selectedTower && canPlaceTower(cell)) {
                        cell.mesh.material.emissive.setHex(0x00ff00); // Green highlight for valid placement
                    } else if (!canPlaceTower(cell) || !gameState.selectedTower) {
                        cell.mesh.material.emissive.setHex(0xff0000); // Red highlight for invalid placement
                    }
                    break; // Only highlight the first valid cell
                }
            }
        }
    }
}

        // Create enemy path
        function createPath() {
            const pathCurve = new THREE.SplineCurve([
                new THREE.Vector2(-gridSize / 2 * cellSize, 0),
                new THREE.Vector2(-gridSize / 4 * cellSize, gridSize / 4 * cellSize),
                new THREE.Vector2(0, gridSize / 3 * cellSize),
                new THREE.Vector2(gridSize / 4 * cellSize, 0),
                new THREE.Vector2(0, -gridSize / 4 * cellSize),
                new THREE.Vector2(-gridSize / 3 * cellSize, -gridSize / 3 * cellSize),
                new THREE.Vector2(gridSize / 2 * cellSize, -gridSize / 2 * cellSize)
            ]);
            
            return pathCurve;
        }
        
        // Visualize the path
        function visualizePath(path) {
            const points = path.getPoints(100);
            const geometry = new THREE.BufferGeometry().setFromPoints(
                points.map(p => new THREE.Vector3(p.x, 0.21, p.y))
            );
            const material = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 3 });
            const line = new THREE.Line(geometry, material);
            scene.add(line);
        }
        
        // Check if a point is near the path
        function isPointNearPath(x, z, pathPoints, threshold) {
            for (const point of pathPoints) {
                const distance = Math.sqrt((x - point.x) ** 2 + (z - point.y) ** 2);
                if (distance < threshold) {
                    return true;
                }
            }
            return false;
        }
        
        // Get grid cell from world position
        function getCellFromPosition(x, z) {
            const gridX = Math.floor(x / cellSize + gridSize / 2);
            const gridZ = Math.floor(z / cellSize + gridSize / 2);
            
            if (gridX >= 0 && gridX < gridSize && gridZ >= 0 && gridZ < gridSize) {
                return grid[gridX][gridZ];
            }
            return null;
        }
        
        // Check if a tower can be placed on a cell
        function canPlaceTower(cell) {
            if (!gameState.selectedTower) return false; // No tower selected
            if (cell.type === 'path' || cell.type === 'rock') return false; // Cannot place on path or rock
            if (cell.type === 'water') return false; // Cannot place on water (unless you add water towers later)
            if (cell.tower) return false; // Cell already has a tower

            // Check if player has enough gold
            const towerCost = towerTypes[gameState.selectedTower].cost;
            return gameState.gold >= towerCost;
        }

        // Place a tower on a cell
        function placeTower(cell, towerType) {
            const towerInfo = towerTypes[towerType];

            // Check if player has enough gold
            if (gameState.gold < towerInfo.cost) return;

            // Deduct gold
            gameState.gold -= towerInfo.cost;
            document.getElementById('gold').textContent = gameState.gold;

            // Create tower mesh
            const towerGeometry = new THREE.CylinderGeometry(0.3, 0.5, 1, 8);
            const towerMaterial = new THREE.MeshPhongMaterial({ color: towerInfo.color });
            const towerMesh = new THREE.Mesh(towerGeometry, towerMaterial);
            towerMesh.position.set(cell.worldX, 0.6, cell.worldZ);
            towerMesh.castShadow = true;
            scene.add(towerMesh);

            // Create tower turret
            const turretGeometry = new THREE.BoxGeometry(0.2, 0.2, 0.8);
            const turretMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });
            const turretMesh = new THREE.Mesh(turretGeometry, turretMaterial);
            turretMesh.position.set(0, 0.5, 0.2);
            towerMesh.add(turretMesh);

            // Create range indicator (hidden by default)
            const rangeGeometry = new THREE.RingGeometry(0.1, towerInfo.range, 32);
            const rangeMaterial = new THREE.MeshBasicMaterial({
                color: 0xffff00,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.3,
                visible: false
            });
            const rangeMesh = new THREE.Mesh(rangeGeometry, rangeMaterial);
            rangeMesh.rotation.x = -Math.PI / 2; // Flat on ground
            rangeMesh.position.y = 0.1;
            towerMesh.add(rangeMesh);

            // Store tower data
            const tower = {
                type: towerType,
                mesh: towerMesh,
                turret: turretMesh,
                range: towerInfo.range,
                rangeMesh: rangeMesh,
                damage: towerInfo.damage,
                fireRate: towerInfo.fireRate,
                cooldown: 0,
                upgradeLevel: 0,
                cell: cell,
                splashRadius: towerInfo.splashRadius
            };

            gameState.towers.push(tower);
            cell.tower = tower;
        }
        
        // Find a target for a tower
        function findTarget(tower) {
            let closest = null;
            let closestDistance = tower.range + 1;
            
            for (const enemy of gameState.enemies) {
                const distance = enemy.mesh.position.distanceTo(tower.mesh.position);
                
                if (distance <= tower.range && distance < closestDistance) {
                    closest = enemy;
                    closestDistance = distance;
                }
            }
            
            return closest;
        }
        
        function fireTower(tower, target) {
            // Rotate turret to face target
            const direction = new THREE.Vector3()
                .subVectors(target.mesh.position, tower.mesh.position)
                .normalize();
            
            tower.turret.lookAt(target.mesh.position);
            
            if (tower.type === 'laser') {
                // Play laser sound
                document.getElementById('laser-sound').play();

                // Create laser beam
                const laserGeometry = new THREE.CylinderGeometry(0.05, 0.05, 1, 8);
                const laserMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                const laserMesh = new THREE.Mesh(laserGeometry, laserMaterial);
                
                // Position and orient the laser
                const distance = tower.mesh.position.distanceTo(target.mesh.position);
                laserMesh.scale.set(1, distance, 1);
                laserMesh.position.copy(tower.mesh.position)
                    .add(direction.clone().multiplyScalar(distance / 2));
                laserMesh.lookAt(target.mesh.position);
                laserMesh.rotateX(Math.PI / 2);
                
                scene.add(laserMesh);
                
                // Add to projectiles with short lifetime
                gameState.projectiles.push({
                    type: 'laser',
                    mesh: laserMesh,
                    lifetime: 0.1,
                    target: target
                });
                
                // Apply damage instantly
                damageEnemy(target, tower.damage);
            } else if (tower.type === 'cannon') {
                // Play cannon sound
                document.getElementById('canon-sound').play();

                // Apply splash damage instantly
                dealSplashDamage(target.mesh.position, tower.splashRadius, tower.damage);
                
                // Create a visual effect for the cannon shot
                const explosionGeometry = new THREE.SphereGeometry(0.5, 8, 8);
                const explosionMaterial = new THREE.MeshBasicMaterial({ color: 0xffaa00 });
                const explosionMesh = new THREE.Mesh(explosionGeometry, explosionMaterial);
                explosionMesh.position.copy(target.mesh.position);
                scene.add(explosionMesh);
                
                // Remove the explosion effect after a short time
                setTimeout(() => {
                    scene.remove(explosionMesh);
                }, 200); // Remove after 200ms
            } else if (tower.type === 'sniper') {
                // Play sniper sound
                document.getElementById('sniper-sound').play();

                // Apply direct damage instantly
                damageEnemy(target, tower.damage);
                
                // Create a visual effect for the sniper shot
                const bulletGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const bulletMaterial = new THREE.MeshBasicMaterial({ color: 0xffd700 });
                const bulletMesh = new THREE.Mesh(bulletGeometry, bulletMaterial);
                bulletMesh.position.copy(tower.mesh.position);
                bulletMesh.position.y += 0.5;
                scene.add(bulletMesh);
                
                // Animate the bullet moving toward the target
                const bulletSpeed = 30;
                const bulletDirection = direction.clone().setY(0.1).normalize();
                const bulletInterval = setInterval(() => {
                    bulletMesh.position.add(bulletDirection.clone().multiplyScalar(bulletSpeed * 0.016)); // Move bullet
                    
                    // Check if bullet reached the target
                    if (bulletMesh.position.distanceTo(target.mesh.position) < 0.5) {
                        clearInterval(bulletInterval);
                        scene.remove(bulletMesh);
                    }
                }, 16); // Approximately 60fps
            }
        }
        
        // Deal splash damage around a point
        function dealSplashDamage(position, radius, damage) {
            for (const enemy of gameState.enemies) {
                const distance = enemy.mesh.position.distanceTo(position);
                
                if (distance <= radius) {
                    // Calculate damage falloff based on distance
                    const falloff = 1 - (distance / radius);
                    const actualDamage = Math.floor(damage * falloff);
                    damageEnemy(enemy, actualDamage);
                }
            }
        }
        
        // Spawn a new enemy
        function spawnEnemy(type) {
            const enemyInfo = enemyTypes[type];
            let geometry;
            
            // Create appropriate geometry based on enemy type
            if (type === 'square') {
                geometry = new THREE.BoxGeometry(enemyInfo.size, enemyInfo.size, enemyInfo.size);
            } else if (type === 'circle') {
                geometry = new THREE.SphereGeometry(enemyInfo.size / 2, 16, 16);
            } else if (type === 'triangle') {
                geometry = new THREE.ConeGeometry(enemyInfo.size / 2, enemyInfo.size, 3);
            } else if (type === 'pentagon') {
                geometry = new THREE.CylinderGeometry(enemyInfo.size / 2, enemyInfo.size / 2, enemyInfo.size / 2, 5);
            }
            
            const material = new THREE.MeshPhongMaterial({ color: enemyInfo.color });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.castShadow = true;
            
            // Position at start of path
            const startPoint = path.getPointAt(0);
            mesh.position.set(startPoint.x, enemyInfo.size / 2, startPoint.y);
            scene.add(mesh);
            
            // Create health bar
            const healthBarWidth = enemyInfo.size * 1.2;
            const healthBarHeight = 0.1;
            
            const healthBarBg = new THREE.Mesh(
                new THREE.PlaneGeometry(healthBarWidth, healthBarHeight),
                new THREE.MeshBasicMaterial({ color: 0x333333, side: THREE.DoubleSide })
            );
            healthBarBg.rotation.x = -Math.PI / 2; // Make it face the camera
            
            const healthBarFg = new THREE.Mesh(
                new THREE.PlaneGeometry(healthBarWidth, healthBarHeight),
                new THREE.MeshBasicMaterial({ color: getHealthBarColor(type), side: THREE.DoubleSide })
            );
            healthBarFg.rotation.x = -Math.PI / 2;
            healthBarFg.position.z = 0.01; // Slightly in front of background
            
            healthBarBg.position.y = enemyInfo.size + 0.2;
            healthBarFg.position.y = enemyInfo.size + 0.2;
            
            mesh.add(healthBarBg);
            mesh.add(healthBarFg);
            
            // Store enemy data
            const enemy = {
                type: type,
                mesh: mesh,
                health: enemyInfo.health,
                maxHealth: enemyInfo.health,
                speed: enemyInfo.speed,
                reward: enemyInfo.reward,
                damage: enemyInfo.damage,
                pathPosition: 0,
                height: enemyInfo.size / 2,
                healthBar: {
                    background: healthBarBg,
                    foreground: healthBarFg,
                    width: healthBarWidth
                }
            };
            
            gameState.enemies.push(enemy);
        }
        
        // Function to get health bar color based on enemy type
        function getHealthBarColor(type) {
            switch(type) {
                case 'square': return 0x00ff00; // Green
                case 'circle': return 0x00ffff; // Cyan
                case 'triangle': return 0xffff00; // Yellow
                case 'pentagon': return 0xff0000; // Red
                default: return 0xffffff; // White
            }
        }
        
        // Update health bar position and scale
        function updateHealthBar(enemy) {
            // Update health bar position to follow enemy
            const healthPercentage = enemy.health / enemy.maxHealth;
            
            // Scale the health bar based on current health
            enemy.healthBar.foreground.scale.x = healthPercentage;
            
            // Position the health bar to align left
            const offset = enemy.healthBar.width * (1 - healthPercentage) / 2;
            enemy.healthBar.foreground.position.x = -offset;
            
            // Make health bar face the camera
            enemy.healthBar.background.lookAt(camera.position);
            enemy.healthBar.foreground.lookAt(camera.position);
        }
        
        // Deal damage to an enemy
        function damageEnemy(enemy, amount) {
            enemy.health -= amount;
            updateHealthBar(enemy);
            
            if (enemy.health <= 0) {
                // Play enemy death sound
                document.getElementById('enemy-death-sound').play();

                // Give player reward
                gameState.gold += enemy.reward;
                document.getElementById('gold').textContent = gameState.gold;
                
                // Create explosion effect
                createExplosion(enemy.mesh.position, enemy.type);
                
                // Remove the enemy
                const index = gameState.enemies.indexOf(enemy);
                if (index !== -1) {
                    removeEnemy(index);
                }
            }
        }
        
        // Remove an enemy from the game
        function removeEnemy(index) {
            const enemy = gameState.enemies[index];
            scene.remove(enemy.mesh);
            gameState.enemies.splice(index, 1);
        }
        
        // Create explosion effect when enemy is destroyed
        function createExplosion(position, type) {
            const particleCount = 15;
            const particles = [];
            const color = enemyTypes[type].color;
            
            for (let i = 0; i < particleCount; i++) {
                const geometry = new THREE.BoxGeometry(0.2, 0.2, 0.2);
                const material = new THREE.MeshBasicMaterial({ color: color });
                const particle = new THREE.Mesh(geometry, material);
                
                // Set position to enemy position
                particle.position.copy(position);
                
                // Random velocity
                particle.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 3,
                    Math.random() * 2,
                    (Math.random() - 0.5) * 3
                );
                
                // Random rotation
                particle.rotation.set(
                    Math.random() * Math.PI * 2,
                    Math.random() * Math.PI * 2,
                    Math.random() * Math.PI * 2
                );
                
                particle.lifetime = 1 + Math.random(); // 1-2 seconds
                
                scene.add(particle);
                particles.push(particle);
            }
            
            // Animate particles
            const animateParticles = function(time) {
                let allDead = true;
                
                for (let i = particles.length - 1; i >= 0; i--) {
                    const particle = particles[i];
                    
                    // Move particle
                    particle.position.add(particle.velocity);
                    
                    // Apply gravity
                    particle.velocity.y -= 0.1;
                    
                    // Rotate particle
                    particle.rotation.x += 0.1;
                    particle.rotation.y += 0.1;
                    
                    // Decrease lifetime
                    particle.lifetime -= 0.016; // Approximately one frame at 60fps
                    
                    // Fade out
                    if (particle.lifetime < 0.5) {
                        particle.material.opacity = particle.lifetime / 0.5;
                        particle.material.transparent = true;
                    }
                    
                    if (particle.lifetime <= 0) {
                        scene.remove(particle);
                        particles.splice(i, 1);
                    } else {
                        allDead = false;
                    }
                }
                
                if (!allDead) {
                    requestAnimationFrame(animateParticles);
                }
            };
            
            requestAnimationFrame(animateParticles);
        }
        
        // Take damage when enemy reaches the end
        function takeDamage(amount) {
            gameState.lives -= amount;
            document.getElementById('lives').textContent = gameState.lives;
            
            // Check if game over
            if (gameState.lives <= 0) {
                // Play game over sound
                document.getElementById('game-over-sound').play();

                alert('Game Over! You survived ' + gameState.currentWave + ' waves.');
                resetGame();
            }
        }
        
        // Reset game state
        function resetGame() {
            // Reset game state
            gameState.gold = 100;
            gameState.lives = 20;
            gameState.currentWave = 0;
            gameState.waveInProgress = false;
            
            // Update UI
            document.getElementById('gold').textContent = gameState.gold;
            document.getElementById('lives').textContent = gameState.lives;
            document.getElementById('wave').textContent = gameState.currentWave;
            
            // Clear all enemies
            for (let i = gameState.enemies.length - 1; i >= 0; i--) {
                removeEnemy(i);
            }
            
            // Clear all projectiles
            for (let i = gameState.projectiles.length - 1; i >= 0; i--) {
                scene.remove(gameState.projectiles[i].mesh);
            }
            gameState.projectiles = [];
            
            // Clear all towers
            for (let i = gameState.towers.length - 1; i >= 0; i--) {
                const tower = gameState.towers[i];
                scene.remove(tower.mesh);
                tower.cell.tower = null;
            }
            gameState.towers = [];
            
            // Deselect tower
            gameState.selectedTower = null;
            document.querySelectorAll('.tower-button').forEach(btn => {
                btn.classList.remove('selected');
            });
        }
        
        // Generate wave definitions for all waves
        function generateWaves() {
            const waves = [];
            
            // Wave 1-5: Mostly squares
            for (let i = 0; i < 5; i++) {
                const wave = [];
                const count = 5 + i * 2; // 5, 7, 9, 11, 13 enemies
                
                for (let j = 0; j < count; j++) {
                    wave.push('square');
                }
                
                // Add a few circles in later waves
                if (i >= 2) {
                    for (let j = 0; j < i; j++) {
                        wave.push('circle');
                    }
                }
                
                waves.push(wave);
            }
            
            // Wave 6-15: Mix of squares, circles, and triangles
            for (let i = 0; i < 10; i++) {
                const wave = [];
                const squareCount = 5 + Math.floor(i / 2); // 5-9 squares
                const circleCount = 5 + Math.floor(i / 2); // 5-9 circles
                const triangleCount = Math.floor(i / 2); // 0-4 triangles
                
                for (let j = 0; j < squareCount; j++) {
                    wave.push('square');
                }
                
                for (let j = 0; j < circleCount; j++) {
                    wave.push('circle');
                }
                
                for (let j = 0; j < triangleCount; j++) {
                    wave.push('triangle');
                }
                
                // Shuffle the wave
                for (let j = wave.length - 1; j > 0; j--) {
                    const k = Math.floor(Math.random() * (j + 1));
                    [wave[j], wave[k]] = [wave[k], wave[j]];
                }
                
                waves.push(wave);
            }
            
            // Wave 16-25: All enemy types including pentagons
            for (let i = 0; i < 10; i++) {
                const wave = [];
                const squareCount = 10 + i; // 10-19 squares
                const circleCount = 10 + i; // 10-19 circles
                const triangleCount = 5 + i; // 5-14 triangles
                const pentagonCount = 1 + Math.floor(i / 2); // 1-5 pentagons
                
                for (let j = 0; j < squareCount; j++) {
                    wave.push('square');
                }
                
                for (let j = 0; j < circleCount; j++) {
                    wave.push('circle');
                }
                
                for (let j = 0; j < triangleCount; j++) {
                    wave.push('triangle');
                }
                
                for (let j = 0; j < pentagonCount; j++) {
                    wave.push('pentagon');
                }
                
                // Shuffle the wave
                for (let j = wave.length - 1; j > 0; j--) {
                    const k = Math.floor(Math.random() * (j + 1));
                    [wave[j], wave[k]] = [wave[k], wave[j]];
                }
                
                waves.push(wave);
            }
            
            return waves;
        }
        
        // Tower upgrade system
        function upgradeTower(tower) {
            const towerType = tower.type;
            const nextLevel = tower.upgradeLevel + 1;
            
            // Check if upgrade is available
            if (nextLevel >= towerTypes[towerType].upgrades.length) {
                console.log('Max upgrade level reached');
                return;
            }
            
            const upgradeCost = towerTypes[towerType].upgrades[nextLevel - 1].cost;
            
            // Check if player has enough gold
            if (gameState.gold < upgradeCost) {
                console.log('Not enough gold for upgrade');
                return;
            }
            
            // Deduct gold
            gameState.gold -= upgradeCost;
            document.getElementById('gold').textContent = gameState.gold;
            
            // Play upgrade sound
            document.getElementById('upgrade-sound').play();

            // Apply upgrade
            const upgradeInfo = towerTypes[towerType].upgrades[nextLevel - 1];
            
            tower.damage = upgradeInfo.damage;
            tower.range = upgradeInfo.range;
            tower.fireRate = upgradeInfo.fireRate;
            if (upgradeInfo.splashRadius) tower.splashRadius = upgradeInfo.splashRadius;
            
            // Update range indicator
            tower.rangeMesh.geometry.dispose();
            tower.rangeMesh.geometry = new THREE.RingGeometry(0.1, tower.range, 32);
            
            // Visual upgrade
            tower.mesh.material.color.setHex(getLevelColor(nextLevel));
            
            // Update tower level
            tower.upgradeLevel = nextLevel;
            
            // Display upgrade notification
            console.log(`Tower upgraded to level ${nextLevel + 1}`);
        }
        
        // Get color for tower level
        function getLevelColor(level) {
            switch(level) {
                case 1: return 0xffaa00; // Bronze
                case 2: return 0xcccccc; // Silver
                case 3: return 0xffdd00; // Gold
                default: return 0xffffff; // White
            }
        }
        
        // Add tower selection and upgrade UI
        function setupTowerUI() {
            // Add this inside your setupTowerUI function:
const eventType = isTouchDevice() ? 'touchstart' : 'click';
window.addEventListener(eventType, (event) => {
    if (gameState.selectedTower && typeof gameState.selectedTower === 'string') {
        // We're in tower placement mode, don't select towers
        return;
    }
    
    // Set the appropriate coordinates based on device type
    if (isTouchDevice() && event.touches && event.touches[0]) {
        touch.x = (event.touches[0].clientX / window.innerWidth) * 2 - 1;
        touch.y = -(event.touches[0].clientY / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(touch, camera);
    } else if (!isTouchDevice()) {
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
    } else {
        return; // Invalid event
    }
    
    const intersects = raycaster.intersectObjects(scene.children);
    
    // Rest of your tower selection code...
});
            // Create tower upgrade button
            const upgradeButton = document.createElement('button');
            upgradeButton.id = 'upgrade-tower';
            upgradeButton.textContent = 'Upgrade Selected Tower';
            upgradeButton.style.position = 'absolute';
            upgradeButton.style.bottom = '60px';
            upgradeButton.style.right = '10px';
            upgradeButton.style.padding = '10px 20px';
            upgradeButton.style.backgroundColor = 'rgba(255, 200, 0, 0.7)';
            upgradeButton.style.color = 'white';
            upgradeButton.style.border = '2px solid white';
            upgradeButton.style.borderRadius = '5px';
            upgradeButton.style.cursor = 'pointer';
            upgradeButton.style.display = 'none'; // Hidden by default
            
            upgradeButton.addEventListener('click', () => {
                const selectedTower = gameState.selectedTower;
                if (selectedTower && typeof selectedTower === 'object') {
                    upgradeTower(selectedTower);
                }
            });
            
            document.body.appendChild(upgradeButton);
            
            // Add click listener to select placed towers
            window.addEventListener('click', (event) => {
                if (gameState.selectedTower && typeof gameState.selectedTower === 'string') {
                    // We're in tower placement mode, don't select towers
                    return;
                }
                
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(scene.children);
                
                // Deselect tower selection buttons
                document.querySelectorAll('.tower-button').forEach(btn => {
                    btn.classList.remove('selected');
                });
                
                // Hide range indicators for all towers
                for (const tower of gameState.towers) {
                    tower.rangeMesh.material.visible = false;
                }
                
                // Hide upgrade button
                upgradeButton.style.display = 'none';
                
                if (intersects.length > 0) {
                    // Check if clicked on a tower
                    for (const tower of gameState.towers) {
                        if (intersects[0].object === tower.mesh || tower.mesh.children.includes(intersects[0].object)) {
                            // Select this tower
                            gameState.selectedTower = tower;
                            
                            // Show range indicator
                            tower.rangeMesh.material.visible = true;
                            
                            // Show upgrade button if not max level
                            if (tower.upgradeLevel < towerTypes[tower.type].upgrades.length) {
                                upgradeButton.textContent = `Upgrade Tower ($${towerTypes[tower.type].upgrades[tower.upgradeLevel].cost})`;
                                upgradeButton.style.display = 'block';
                            }
                            
                            return;
                        }
                    }
                    
                    // Clicked elsewhere, deselect tower
                    gameState.selectedTower = null;
                }
            });
        }
        
        // Initialize fast forward button
        function setupFastForwardButton() {
            const ffButton = document.createElement('button');
            ffButton.id = 'fast-forward';
            ffButton.textContent = '>> Fast Forward';
            ffButton.style.position = 'absolute';
            ffButton.style.bottom = '10px';
            ffButton.style.right = '150px';
            ffButton.style.padding = '10px 20px';
            ffButton.style.backgroundColor = 'rgba(0, 0, 100, 0.7)';
            ffButton.style.color = 'white';
            ffButton.style.border = '2px solid white';
            ffButton.style.borderRadius = '5px';
            ffButton.style.cursor = 'pointer';
            
             // Use both touchstart and click events for mobile and desktop
    const eventType = isTouchDevice() ? 'touchstart' : 'click';
    ffButton.addEventListener(eventType, () => {
        fastMode = !fastMode;
                
                if (fastMode) {
                    // Double game speed
                    ffButton.textContent = '> Normal Speed';
                    ffButton.style.backgroundColor = 'rgba(100, 0, 0, 0.7)';
                    
                    // Adjust enemy speeds
                    for (const enemy of gameState.enemies) {
                        enemy.speed *= 2;
                    }
                    
                    // Adjust tower fire rates
                    for (const tower of gameState.towers) {
                        tower.fireRate /= 2;
                    }
                } else {
                    // Normal game speed
                    ffButton.textContent = '>> Fast Forward';
                    ffButton.style.backgroundColor = 'rgba(0, 0, 100, 0.7)';
                    
                    // Reset enemy speeds
                    for (const enemy of gameState.enemies) {
                        enemy.speed /= 2;
                    }
                    
                    // Reset tower fire rates
                    for (const tower of gameState.towers) {
                        tower.fireRate *= 2;
                    }
                }
            });
            
            document.body.appendChild(ffButton);
        }
        
        // Initialize the game UI
        setupTowerUI();
        setupFastForwardButton();

       // Enemy types, waves, scene setup, etc. (your existing code)

        // Main Menu Functions
        function startGame() {
            // Hide the main menu
            document.getElementById('main-menu').style.display = 'none';
            
            // Show the game UI
            document.getElementById('ui').style.display = 'block';
            document.getElementById('tower-selection').style.display = 'flex';
            document.getElementById('start-wave').style.display = 'block';
            
            // Stop title music and play game music
            document.getElementById('title-music').pause();
            document.getElementById('game-music').play();
            
            // Reset the game state
            resetGame();
        }

        function showInstructions() {
            // Hide the main menu
            document.getElementById('main-menu').style.display = 'none';
            
            // Show the instructions
            document.getElementById('instructions').style.display = 'block';
        }

        function backToMenu() {
            // Hide the instructions
            document.getElementById('instructions').style.display = 'none';
            
            // Show the main menu
            document.getElementById('main-menu').style.display = 'block';
            
            // Stop game music and play title music
            document.getElementById('game-music').pause();
            document.getElementById('title-music').play();
        }

        function exitGame() {
            // Close the game window (or redirect to another page)
            window.close();
        }

        // Prevent default touch behavior to avoid scrolling or zooming
document.body.addEventListener('touchstart', function (event) {
    // Only prevent default if we're in the game (not in menus)
    if (document.getElementById('main-menu').style.display === 'none') {
        event.preventDefault();
    }
}, { passive: false });
    </script>
</body>
</html>
